%%%%%%%%%%%%%
% LECTURE 8 %
%%%%%%%%%%%%%

\newpage
\noindent\lecture{8}{29/10/2021}
\vspace{0.5cm}
\subsection{Violazione della crittografia RSA}
Dal momento che l'algoritmo quantistico del period finding di Shor è spesso descritto come un algoritmo di fattorizzazione, concludiamo questa sezione osservando come il period finding porti alla fattorizzazione. Consideriamo solo il caso relativo alla \textbf{crittografia RSA} (R. Rivest, A. Shamir e L. Adleman), dove si vuole fattorizzare il prodotto di due grandi numeri primi, sebbene la connessione tra period finding e fattorizzazione sia più generale.

\noindent Supponiamo di avere un numero $N=pq$, tale per cui $N, p$ e $q$ siano molto grandi e $p,q$ siano fattori primi. Nel CC fattorizzare $N$ richiederebbe un tempo di esecuzione esponenziale mentre nel QC ci si riduce a un tempo polinomiale. Vediamo ora come interviene l'algoritmo di Shor.

\noindent Prendiamo una funzione $f(x)=a^x\pmod N$, di periodo $r$ ($f(x+r)=f(x)$) e dove $r$ è tale per cui:
\begin{itemize}
    \item $a^r\equiv1 \pmod N$;
    \item Se $r$ è la più piccola soluzione del punto precedente allora $r$ è l'ordine di $a\pmod N$;
    \item $r$ è definito come $r<N$.
\end{itemize}
Quest'ultimo risultato è ottenuto a partire dalla teoria dei numeri nel caso particolare in cui $N$ è prodotto di due numeri primi, proprio come nel nostro caso.

Introduciamo il seguente teorema

\begin{teorema}[\textbf{Teorema di Eulero}]
    Se prendiamo $a$ coprimo a $p$ e $q$, allora $a$ può essere espresso come
    \begin{equation*}
        a^{(p-1)(q-1)}=1\pmod{pq}
    \end{equation*}
\end{teorema}

\noindent Osserviamo che con le assunzioni fatte all'inizio e su $r$ siamo nelle ipotesi del teorema di Eulero, l'algoritmo di Shor può essere dunque utilizzato per trovare l'ordine $r$ di un intero $a\pmod N$.

\noindent Iniziamo con il considerare $N=pq$, vogliamo trovare i valori di $p$ e $q$. Scegliamo $a$ coprimo a $N$, verificare che siano coprimi tra loro non è difficile, esiste un teorema di Euclide molto famoso che può essere eseguito su un computer classico, ciò che è invece difficile è trovare tutti i possibili divisori di un numero $N$. A questo punto usiamo il QC per trovare l'ordine $r$ di $a^r\equiv1 \pmod N$, in particolar modo facciamo due assunzioni:
\begin{enumerate}
    \item Supponiamo che $r$ sia \textbf{pari}, sotto questa ipotesi possiamo definire l'intero $x=a^{\frac r2}\pmod N$ che ha la seguente proprietà:
        \begin{equation*}
            \pmod N 0 =a^r-1 = x^2-1=(x-1)(x+1)
        \end{equation*}
        Richiediamo che $x-1\neq 0\pmod N$ perché se non fosse così, $a^\frac r2 =1 \pmod N$, l'ordine non sarebbe più $r$, ma $r/2$;
    \item Supponiamo di essere fortunati e che anche $x+1\neq 0 \pmod N$.
\end{enumerate}
Ora il prodotto $(x-1)(x+1)$ è un multiplo di $N$, ma i singoli fattori non sono un multiplo di $N$, in quanto $x+1\neq 0 \pmod N$ e $x+1\neq 0 \pmod N$. Tuttavia $(x-1)$ è multiplo di $p$ e $(x+1)$ è multiplo di $q$. In particolare noi possiamo andare a calcolare classicamente il massimo comune divisore di
\begin{equation*}
    p=\gcd{(x-1,N)} \qquad q=\gcd{(x+1,N)}
\end{equation*}
Se non siamo fortunati, scegliamo un altro numero che soddisfi le due assunzioni. \newline
Uno potrebbe porsi la seguente domanda: perché fattorizzare gli interi è importante? Perché è possibile violare la crittografia RSA.
\begin{esempio}[\textbf{Protocollo RSA}]
    Iniziamo facendo delle premesse: supponiamo che Bob possieda due grandi primi $p$ e $q$, il cui prodotto sia un grande intero $N$. Sia $c$ un numero che non ha alcun fattore in comune con $(p-1)(q-1)$. Consideriamo ora Alice, supponiamo che conosca $N$ e $c$, ma non possieda alcuna informazione su $p$ e $q$. \newline 
    Il protocollo RSA lavora nel seguente modo:
    \begin{itemize}
        \item Alice possiede un messaggio codificato in $a$;
        \item Alice calcola $b=a^c\pmod N$;
        \item Bob decodifica il messaggio, può calcolare $cd$, dove $cd=1 \pmod{(p-1)(q-1)}$;
        \item Si scopre che, in teoria dei numeri, c'è una dimostrazione che mostra il seguente risultato:
            \begin{equation*}
                a=b^d\pmod N
            \end{equation*}
        \item Se conosciamo $b$ e se siamo in possesso di $c$ e $d$, possiamo ricavare $a$, cioè il messaggio. 
    \end{itemize}
\end{esempio}
Questo è come funziona il \textbf{protocollo RSA}. Per decodificare il messaggio necessitiamo $d$, ma per conoscere $d$ abbiamo bisogno di $p$ e $q$, questo perché conoscere solo $N$ e $c$ non è sufficiente per ricavare $d$. È qui che si evidenzia l'importanza di fattorizzare gli interi, se vogliamo decodificare il messaggio. La potenza del protocollo RSA sta nel fatto che nel CC sarebbero richieste risorse esponenziali per poter trovare i fattori primi mentre nel QC parliamo di tempi polinomiali. \newline
L'algoritmo di Shor può violare altri protocolli crittografici, come ad esempio il \textbf{protocollo Diffie-Hellman} perché è in grado di risolvere i logaritmi discreti, utilizzati in quest'ultimo protocollo.
\section{Algoritmo di Grover}
L'ultimo algoritmo che affrontiamo per mostrare ancora una volta che le prestazioni del QC sono nettamente migliori rispetto a quelle del CC, è l'\textbf{algoritmo di ricerca di Grover}. L'idea è quella di avere a disposizione $N$ oggetti e di cercarne uno specifico che identifichiamo con $a$. In maniera astratta potremmo pensare di avere una funzione $f(x)$ che può valutare i valori di $x$ nell'insieme $\{0,\dots, N-1\}$ e vale $f(x)=1$ se $x=a$ mentre vale $f(x)=0$ per $x\neq a$, in termini matematici:
\begin{equation*}
    f(x):\{0, \dots, N-1\}\rightarrow\{0,1\}
\end{equation*}
\begin{equation*}
    f(x)=\begin{cases}
        1 \qquad x=a\\
        0 \qquad x\neq a\\
    \end{cases}
\end{equation*}
Questo tipo di algoritmo può essere utilizzato per cercare determinati prodotti su un marketplace oppure in un problema matematico.
\begin{esempio}[\textbf{Problema matematico}]
    Consideriamo un numero $p$ definito come
    \begin{equation*}
        p=x^2+y^2
    \end{equation*}
    dove $x$, $y$ sono due numeri interi che vogliamo trovare. Per tutti gli $x$ possiamo valutare $\sqrt{p^2-x^2}$ fino a quando non troviamo un intero $y$.
\end{esempio}
\noindent Nel CC, questo tipo di algoritmo può essere risolto con una probabilità del 50\% che corrisponde a $\frac N2$ operazioni, siccome $\frac N2$ è dell'ordine di $N$, in termini di esecuzione sono richieste $\order{N}$ operazioni. Dal punto di vista invece del QC, sono richieste $\order{\sqrt N}$ operazioni. \newline
Iniziamo con il nostro solito circuito per capire come funzione l'algoritmo di Grover:
\begin{center}
    \mbox{
        \Qcircuit @C=1em @R=1em {
            \lstick{\ket{0}^{\otimes n}} & \gate{H^{\otimes n}} & \multigate{1}{U_f} & \qw \\
            \lstick{\ket{1}}             & \gate{H}             & \ghost{U_f}        & \qw
        }
    }
\end{center}
che produce lo stato
\begin{equation*}
    \frac{1}{2^{\frac n2}}\sum_{x=0}^{2^n-1}(-1)^{f(x)}\ket{x}\otimes \underbrace{\frac{\ket{0}-\ket{1}}{\sqrt 2}}_{\substack{\text{Termine} \\ \text{irrilevante\footnote{Si veda l'algoritmo di Deutch}}}}.
\end{equation*}
Ricordiamo che l'azione di $f(x)$ produce i valori $0$ o $1$, in questo caso ciò che si realizza è un termine di fase. Nel gergo comune, si è soliti identificare la nostra black-box $U_f$ con il nome \textbf{oracle} ($O$). La sua azione sarà quindi:
\begin{equation*}
    \begin{aligned}
        O\ket{x}=(-1)^{f(x)}\ket x = 
            \begin{cases}
                -\ket x \quad &x=a\\
                \ket x \quad &x\neq a
            \end{cases}
    \end{aligned}
\end{equation*}
La sua azione e il resto dell'algoritmo può essere descritto in due modi:
\subsection*{Interpretazione geometrica}
L'applicazione di $O$ su un generico stato $\ket x$ può essere vista come una riflessione rispetto a un asse. Consideriamo lo spazio di $\mathcal{H}$ come formato dallo spazio contenente soltanto $\ket a$ e dallo spazio ortogonale ad $\ket a$ che definiamo come:
\begin{equation*}
    \{\ket a\}^\perp=\{\ket x \in \mathcal{H}:\ip{a}{x}=0\}
\end{equation*}
Un generico vettore $\ket x \in \mathcal{H}$ può essere rappresentato all'interno di questo piano.
[GRAFICO]\\
L'azione di $O$ può essere interpretata in questo modo:
\begin{itemize}
    \item Se $\ket x = \ket a$, allora $O$ esegue una riflessione rispetto all'asse $\{\ket a\}^\perp$;
    \item Se $\ket x \neq \ket a$, allora $O$ non fa nulla, rimane uguale a se stesso.
\end{itemize}
Possiamo definire $O$ come
\begin{equation*}
    O=\mathbb{I}-2\op{a}{a}
\end{equation*}
Vediamo la sua azione
\begin{equation*}
        \begin{array}{ll}
            O\ket a=\ket a -2\ket{a}\underbrace{\ip{a}{a}}_{1}=\ket a - 2\ket{a} = -\ket{a} & \text{riflessione}\\
            O\ket x=\ket x -2\ket{a}\underbrace{\ip{a}{x}}_{0}= \ket{x} & \text{nessuna riflessione}
        \end{array}
\end{equation*}
Ora, il nostro stato iniziale era
\begin{equation*}
    \ket{0}^{\otimes n}\rightarrow H^{\otimes n}\ket{0}^{\otimes n}=\frac{1}{2^{\frac n2}}\sum_{x=0}^{2^n-1}\equiv \ket\phi
\end{equation*}
Definiamo un'altra operazione di riflessione $G$ rispetto a $\ket\phi$ tale per cui
\begin{equation*}
    \begin{array}{ll}
        G\ket\phi=\phi \\
        \ip{x}{\phi}=0 \rightarrow G\ket x=-\ket x
    \end{array}
\end{equation*}
In questo modo vediamo che $G$ è della forma:
\begin{equation*}
    G=2\op{\phi}{\phi}-\mathbb{I}
\end{equation*}
Questo operatore può essere costruito in termini di gate in maniera semplice ricordando che 
\begin{equation*}
    \begin{array}{ll}
        \ket{0}^{\otimes n}\rightarrow \ket{0}^{\otimes n}\\
        \ket{x}^{\otimes n}\rightarrow -\ket{x}^{\otimes n} \qquad x\neq 0
    \end{array}
\end{equation*}
\begin{center}
    \mbox{
        \Qcircuit @C=1em @R=1em {
            & \qw                         & \multigate{2}{G} & \qw                     & \qw \\
            & \raisebox{.3em}{\vdots}     & \nghost{G}       & \raisebox{.3em}{\vdots} &     \\
            & \qw                         & \ghost{G}        & \qw                     & \qw
        }
    }
    \raisebox{-2.3em}{=}
    \mbox{
        \Qcircuit @C=1em @R=1em {
            & \qw
            & \multigate{2}{H^{\otimes n}}
            & \qw
            & \multigate{2}{
                \begin{array}{ll}
                    \ket{0}^{\otimes n}\rightarrow \ket{0}^{\otimes n}\\
                    \ket{x}^{\otimes n}\rightarrow -\ket{x}^{\otimes n}
                \end{array}}
            & \qw
            & \multigate{2}{H^{\otimes n}}
            & \qw
            & \qw 
            \\
            & \raisebox{.3em}{\vdots}
            & \nghost{H^{\otimes n}}
            & \raisebox{.3em}{\vdots}
            & \nghost{
                \begin{array}{ll}
                    \ket{0}^{\otimes n}\rightarrow \ket{0}^{\otimes n}\\
                    \ket{x}^{\otimes n}\rightarrow -\ket{x}^{\otimes n}
                \end{array}}
            & \raisebox{.3em}{\vdots}
            & \nghost{H^{\otimes n}}
            & \raisebox{.3em}{\vdots}
            &
            \\
            & \qw
            & \ghost{H^{\otimes n}}
            & \qw
            & \ghost{
                \begin{array}{ll}
                    \ket{0}^{\otimes n}\rightarrow \ket{0}^{\otimes n}\\
                    \ket{x}^{\otimes n}\rightarrow -\ket{x}^{\otimes n}
                \end{array}}
            & \qw
            & \ghost{H^{\otimes n}}
            & \qw
            & \qw
        }
    }
\end{center}
Troviamo che
\begin{equation*}
    G=H^{\otimes n}(2\ket{0}^{\otimes n}\bra{0}^{\otimes n}-\mathbb{I})H^{\otimes n}=2\op{\phi}{\phi}-\mathbb{I}
\end{equation*}
Dal momento che \texttt{H-gate} è unitario e $\ket \phi = H^{\otimes n}\ket{0}^{\otimes n}$.
Abbiamo quindi due operazioni $O$ e $G$ che agiscono così
[GRAFICO]
L'algoritmo di Grover è quindi l'applicazione ripetuta k volte di $GO$, ricordiamo che l'applicazione viene eseguita da destra verso sinistra, per cui avremo $\underbrace{\dots GOGOGO}_{k}=(GO)^k$. Dopo $\order{\sqrt N}$ applicazioni, vedremo il nostro elemento $\ket a$ con probabilità prossima all'unità.
Supponiamo che $\ket \phi = \frac{1}{2^{\frac n2}}\sum_{x=0}^{2^n-1}\ket x$, allora il prodotto scalare tra $\phi$ e $a$ sarà
\begin{equation*}
    \ip{a}{\phi}=\frac{1}{2^{\frac n2}} \ll 1 \quad \text{numero piccolo}
\end{equation*}
Possiamo quindi dire che $\phi$ è quasi ortogonale ad $a$. Dal momento che
\begin{equation*}
    \theta\approx\sin\theta = \cos \left(\frac \pi 2 -\theta \right) \Rightarrow \ip{a}{\phi} = \cos \left(\frac \pi 2 - \theta \right)=\frac{1}{2^{\frac n2}}\ll 1 \Rightarrow \theta \approx \frac{1}{2^{\frac n2}}
\end{equation*}
Siccome i nostri oggetti nel database sono $N=2^n$ (con $N$ grande e $n$ numero di qubits), allora $\theta\sim \frac{1}{\sqrt N}$. 
L'azione di $O$ e $G$ dopo, è una doppia riflessione, cioè una rotazione. Per cui dopo l'azione di $O$ e poi $G$, lo stato $\phi$ passerà da un angolo $\theta$ a un angolo $3\theta$. Applicando nuovamente la sequenza $O$ e poi $G$ passerà da un angolo $3\theta$ a $5\theta$. Iterando questo procedimento per un certo numero di volte che indichiamo con $r$, avremo che $\theta +2r\theta\approx\frac \pi 2$. Dopo quante iterazione otteniamo $\frac \pi 2$? $r=\frac{\pi}{4\theta}-\frac 12$. Ma $\theta$ è piccolo, per cui:
\begin{equation*}
    r\approx \frac{\pi}{4\theta}=\frac \pi 4 \theta^{-1}\approx \frac \pi 4 \sqrt N
\end{equation*}
Abbiamo che $r$ è quasi allineato con $\ket a$. Dopo $\order{\sqrt N}$ iterazioni di $GO$, arriviamo allo stato $\ket a$ con probabilità quasi 1. Possiamo calcolare $\ket a$ attraverso una misura finale dello stato $(GO)^r\ket \phi$, infatti 
\begin{equation*}
    (GO)^r\ket \phi = \sqrt{1-\varepsilon^2}\ket a + \varepsilon \ket{a}^\perp \quad \varepsilon \ll 1
\end{equation*}
Se siamo sfortunati e non otteniamo $\ket a$, possiamo eseguire nuovamente l'algoritmo magari incrementando il numero di iterazioni e provare a misurare nuovamente. Dopo un numero limitato di tentativi troveremo $a$!
\subsection*{Interpretazione grafica: inversione rispetto alla media}
Iniziamo con il considerare un generico stato $\ket \psi = \sum \alpha_x\ket x$. L'operatore $O$ inverte l'ampiezza per $x=a$
\begin{equation*}
    \begin{aligned}
        \begin{cases}
            \alpha_x \rightarrow -\alpha_x \quad &x=a\\
            \alpha_x \rightarrow \alpha_x \quad &x\neq a
        \end{cases}
    \end{aligned}
\end{equation*}
L'operatore $G$ è una riflessione lungo lo stato con uguale ampiezza $\alpha_x=\frac 1 {\sqrt N}$
\begin{equation*}
    \begin{array}{ll}
        G=2\op{\phi}{\phi}-\mathbb{I} \\
        \ket \phi = \frac {1}{\sqrt N} \sum_{x=0}^{2^n-1}\ket x = \frac{1}{2^{\frac n2}}\sum_{x=0}^{2^n-1}\ket x
    \end{array}
\end{equation*}
E la sua azione su $\psi$ non è molto complicata
\begin{equation*}
    \begin{aligned}
        G\ket \psi &= 2 \frac 1 N \sum_{x=0}^{2^n-1}\ket x \sum_{y=0}^{2^n-1}\bra y \left(\sum_{z=0}^{2^n-1}\alpha_z \ket z\right) - \sum_{x=0}^{2^n-1}\alpha_x\ket x \\
        & = \sum_{x=0}^{2^n-1}\left(2\sum_{y=0}^{2^n-1} \frac{\alpha_y}{N} - \alpha_x \right)\ket x \\
        & = \sum_{x=0}^{2^n-1}\left(2\expval{\alpha}-\alpha_x\right)\ket x
    \end{aligned}
\end{equation*}
dove $\expval{\alpha}=\sum_{x=0}^{2^n-1}\frac {\alpha_x}{N}$. Perciò su ogni componente
\begin{equation*}
    \alpha_x \rightarrow 2\expval{\alpha}-\alpha_x
\end{equation*}
c'è una riflessione rispetto all'ampiezza media.